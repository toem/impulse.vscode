#!/bin/bash
# Script to create per-platform link folders for README/LICENSE/CHANGELOG and image folders
# Usage: edit the function calls at the end of this script to list platform directories to process.
#
# The script will create folders in the current directory named after each provided platform,
# and add symlinks to README.md, LICENSE.md, CHANGELOG.md, and any image folder in the platform.

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

echo_warning() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

echo_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Always use script directory for links (directory where this script resides)
TARGET_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# 1) Show existing subdirectories in this script directory and ask for confirmation before cleaning
echo_info "Target directory: $TARGET_DIR"

# Collect immediate subdirectories
mapfile -t SUBDIRS < <(find "$TARGET_DIR" -mindepth 1 -maxdepth 1 -type d -print | sort)

if [[ ${#SUBDIRS[@]} -eq 0 ]]; then
    echo_info "No platform folders found in $TARGET_DIR; nothing to remove."
else
    echo_info "Found ${#SUBDIRS[@]} platform folder(s):"
    for d in "${SUBDIRS[@]}"; do
        echo "  - $(basename "$d")"
    done

    # Prompt for confirmation
    read -r -p "$(echo -e "${YELLOW}Continue and remove these folders? [y/N] ${NC}")" ANSWER
    case "$ANSWER" in
        y|Y)
            echo_info "Proceeding with removal of ${#SUBDIRS[@]} folder(s)..."
            for d in "${SUBDIRS[@]}"; do
                rm -rf "$d"
            done
            ;;
        *)
            echo_info "Aborted by user. No folders were removed."
            exit 0
            ;;
    esac
fi

# Define a function that takes one argument: path to the platform folder to process
process_platform() {
    local ext_dir="$1"

    if [[ -z "$ext_dir" ]]; then
        echo_error "process_platform: no directory provided" >&2
        return 1
    fi

    # Resolve to absolute path if possible
    if ! ext_dir="$(readlink -f "$ext_dir" 2>/dev/null)"; then
        echo_warning "process_platform: failed to resolve path '$1', using as-is" >&2
        ext_dir="$1"
    fi

    if [[ ! -d "$ext_dir" ]]; then
        echo_error "process_platform: directory '$ext_dir' does not exist, skipping." >&2
        return 1
    fi

    local ext_name dest_dir
    ext_name="$(basename "$ext_dir")"
    dest_dir="$TARGET_DIR/$ext_name"

    mkdir -p "$dest_dir"

    # Link README.md, LICENSE.md, CHANGELOG.md if they exist
    for f in README.md LICENSE.md CHANGELOG.md; do
        if [[ -f "$ext_dir/$f" ]]; then
            ln -sfn "$ext_dir/$f" "$dest_dir/$f"
            echo_info "Linked $ext_dir/$f -> $dest_dir/$f"
        else
            echo_warning "Missing $f in $ext_dir, skipping."
        fi
    done

    # Find image folder(s) directly under the platform directory (image*, images, img)
    find "$ext_dir" -maxdepth 1 -type d \( -iname 'image*' -o -iname 'images' -o -iname 'img' \) ! -path "$ext_dir" -print0 |
    while IFS= read -r -d $'\0' img_dir; do
        img_name="$(basename "$img_dir")"
        ln -sfn "$img_dir" "$dest_dir/$img_name"
        echo_info "Linked image folder $img_dir -> $dest_dir/$img_name"
    done
}

# Call process_platform with the platform directories you want to link.
# Examples (uncomment and edit to suit your environment):
# process_platform "/path/to/some-platform"
process_platform "../de.toem.impulse.vscode"

